/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Crypto/CommonCrypto.swift:
    1|       |//
    2|       |//  CommonCrypto.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/12/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//  For more info review https://medium.com/@vialyx/security-data-transforms-with-swift-aes256-on-ios-6509917497d
    8|       |//
    9|       |
   10|       |import UIKit
   11|       |import CommonCrypto
   12|       |
   13|       |protocol Randomizer {
   14|       |    static func randomIv() -> Data
   15|       |    static func randomSalt() -> Data
   16|       |    static func randomData(length: Int) -> Data
   17|       |}
   18|       |
   19|       |protocol Crypter {
   20|       |    func encrypt(_ digest: Data) throws -> Data
   21|       |    func decrypt(_ encrypted: Data) throws -> Data
   22|       |}
   23|       |
   24|       |struct AES256Crypter {
   25|       |    
   26|       |    private var key: Data
   27|       |    private var iv: Data
   28|       |    
   29|      1|    public init(key: Data, iv: Data) throws {
   30|      1|        guard key.count == kCCKeySizeAES256 else {
   31|      0|            throw Error.badKeyLength
   32|      1|        }
   33|      1|        guard iv.count == kCCBlockSizeAES128 else {
   34|      0|            throw Error.badInputVectorLength
   35|      1|        }
   36|      1|        self.key = key
   37|      1|        self.iv = iv
   38|      1|    }
   39|       |    
   40|       |    enum Error: Swift.Error {
   41|       |        case keyGeneration(status: Int)
   42|       |        case cryptoFailed(status: CCCryptorStatus)
   43|       |        case badKeyLength
   44|       |        case badInputVectorLength
   45|       |    }
   46|       |    
   47|      2|    private func crypt(input: Data, operation: CCOperation) throws -> Data {
   48|      2|        var outLength = Int(0)
   49|      2|        var outBytes = [UInt8](repeating: 0, count: input.count + kCCBlockSizeAES128)
   50|      2|        var status: CCCryptorStatus = CCCryptorStatus(kCCSuccess)
   51|      2|        input.withUnsafeBytes { (encryptedBytes: UnsafePointer<UInt8>!) -> () in
   52|      2|            iv.withUnsafeBytes { (ivBytes: UnsafePointer<UInt8>!) in
   53|      2|                key.withUnsafeBytes { (keyBytes: UnsafePointer<UInt8>!) -> () in
   54|      2|                    status = CCCrypt(operation,
   55|      2|                                     CCAlgorithm(kCCAlgorithmAES128),            // algorithm
   56|      2|                        CCOptions(kCCOptionPKCS7Padding),           // options
   57|      2|                        keyBytes,                                   // key
   58|      2|                        key.count,                                  // keylength
   59|      2|                        ivBytes,                                    // iv
   60|      2|                        encryptedBytes,                             // dataIn
   61|      2|                        input.count,                                // dataInLength
   62|      2|                        &outBytes,                                  // dataOut
   63|      2|                        outBytes.count,                             // dataOutAvailable
   64|      2|                        &outLength)                                 // dataOutMoved
   65|      2|                }
   66|      2|            }
   67|      2|        }
   68|      2|        guard status == kCCSuccess else {
   69|      0|            throw Error.cryptoFailed(status: status)
   70|      2|        }
   71|      2|        return Data(bytes: UnsafePointer<UInt8>(outBytes), count: outLength)
   72|      2|    }
   73|       |    
   74|      1|    static func createKey(password: Data, salt: Data) throws -> Data {
   75|      1|        let length = kCCKeySizeAES256
   76|      1|        var status = Int32(0)
   77|      1|        var derivedBytes = [UInt8](repeating: 0, count: length)
   78|      1|        password.withUnsafeBytes { (passwordBytes: UnsafePointer<Int8>!) in
   79|      1|            salt.withUnsafeBytes { (saltBytes: UnsafePointer<UInt8>!) in
   80|      1|                status = CCKeyDerivationPBKDF(CCPBKDFAlgorithm(kCCPBKDF2),                  // algorithm
   81|      1|                    passwordBytes,                                // password
   82|      1|                    password.count,                               // passwordLen
   83|      1|                    saltBytes,                                    // salt
   84|      1|                    salt.count,                                   // saltLen
   85|      1|                    CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA1),   // prf
   86|      1|                    10000,                                        // rounds
   87|      1|                    &derivedBytes,                                // derivedKey
   88|      1|                    length)                                       // derivedKeyLen
   89|      1|            }
   90|      1|        }
   91|      1|        guard status == 0 else {
   92|      0|            throw Error.keyGeneration(status: Int(status))
   93|      1|        }
   94|      1|        return Data(bytes: UnsafePointer<UInt8>(derivedBytes), count: length)
   95|      1|    }
   96|       |    
   97|       |}
   98|       |
   99|       |class CommonCrypto: NSObject {
  100|       |    
  101|       |}
  102|       |
  103|       |extension AES256Crypter: Crypter {
  104|       |    
  105|      1|    func encrypt(_ digest: Data) throws -> Data {
  106|      1|        return try crypt(input: digest, operation: CCOperation(kCCEncrypt))
  107|      1|    }
  108|       |    
  109|      1|    func decrypt(_ encrypted: Data) throws -> Data {
  110|      1|        return try crypt(input: encrypted, operation: CCOperation(kCCDecrypt))
  111|      1|    }
  112|       |    
  113|       |}
  114|       |
  115|       |extension AES256Crypter: Randomizer {
  116|       |    
  117|      1|    static func randomIv() -> Data {
  118|      1|        return randomData(length: kCCBlockSizeAES128)
  119|      1|    }
  120|       |    
  121|      1|    static func randomSalt() -> Data {
  122|      1|        return randomData(length: 8)
  123|      1|    }
  124|       |    
  125|       |    static func randomData(length: Int) -> Data {
  126|       |        var data = Data(count: length)
  127|      2|        let status = data.withUnsafeMutableBytes { mutableBytes in
  128|      2|            SecRandomCopyBytes(kSecRandomDefault, length, mutableBytes)
  129|      2|        }
  130|      2|        assert(status == Int32(0))
  131|       |        return data
  132|       |    }
  133|       |    
  134|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/Color+Extension.swift:
    1|       |//
    2|       |//  Color+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class Color_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension UIColor {
   16|       |    
   17|      0|    convenience init(red: Int, green: Int, blue: Int) {
   18|      0|        assert(red >= 0 && red <= 255, "Invalid red component")
   19|      0|        assert(green >= 0 && green <= 255, "Invalid green component")
   20|      0|        assert(blue >= 0 && blue <= 255, "Invalid blue component")
   21|      0|        
   22|      0|        self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: 1.0)
   23|      0|    }
   24|       |    
   25|      0|    convenience init(rgb: Int) {
   26|      0|        self.init(
   27|      0|            red: (rgb >> 16) & 0xFF,
   28|      0|            green: (rgb >> 8) & 0xFF,
   29|      0|            blue: rgb & 0xFF
   30|      0|        )
   31|      0|    }
   32|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/Date+Extension.swift:
    1|       |//
    2|       |//  Date+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class Date_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension Date {
   16|       |    
   17|       |    /// Returns the amount of years from another date
   18|      0|    func years(from date: Date) -> Int {
   19|      0|        return Calendar.current.dateComponents([.year], from: date, to: self).year ?? 0
   20|      0|    }
   21|       |    /// Returns the amount of months from another date
   22|      0|    func months(from date: Date) -> Int {
   23|      0|        return Calendar.current.dateComponents([.month], from: date, to: self).month ?? 0
   24|      0|    }
   25|       |    /// Returns the amount of weeks from another date
   26|      0|    func weeks(from date: Date) -> Int {
   27|      0|        return Calendar.current.dateComponents([.weekOfMonth], from: date, to: self).weekOfMonth ?? 0
   28|      0|    }
   29|       |    /// Returns the amount of days from another date
   30|      0|    func days(from date: Date) -> Int {
   31|      0|        return Calendar.current.dateComponents([.day], from: date, to: self).day ?? 0
   32|      0|    }
   33|       |    /// Returns the amount of hours from another date
   34|      0|    func hours(from date: Date) -> Int {
   35|      0|        return Calendar.current.dateComponents([.hour], from: date, to: self).hour ?? 0
   36|      0|    }
   37|       |    /// Returns the amount of minutes from another date
   38|      0|    func minutes(from date: Date) -> Int {
   39|      0|        return Calendar.current.dateComponents([.minute], from: date, to: self).minute ?? 0
   40|      0|    }
   41|       |    /// Returns the amount of seconds from another date
   42|      0|    func seconds(from date: Date) -> Int {
   43|      0|        return Calendar.current.dateComponents([.second], from: date, to: self).second ?? 0
   44|      0|    }
   45|       |    /// Returns the amount of nanoseconds from another date
   46|      0|    func nanoseconds(from date: Date) -> Int {
   47|      0|        return Calendar.current.dateComponents([.nanosecond], from: date, to: self).nanosecond ?? 0
   48|      0|    }
   49|       |    /// Returns the a custom time interval description from another date
   50|      0|    func offset(from date: Date) -> String {
   51|      0|        var result: String = ""
   52|      0|        if years(from: date)   > 0 { return "\(years(from: date))y"   }
   53|      0|        if months(from: date)  > 0 { return "\(months(from: date))M"  }
   54|      0|        if weeks(from: date)   > 0 { return "\(weeks(from: date))w"   }
   55|      0|        if seconds(from: date) > 0 { return "\(seconds(from: date))" }
   56|      0|        if days(from: date)    > 0 { result = result + " " + "\(days(from: date)) D" }
   57|      0|        if hours(from: date)   > 0 { result = result + " " + "\(hours(from: date)) H" }
   58|      0|        if minutes(from: date) > 0 { result = result + " " + "\(minutes(from: date)) M" }
   59|      0|        if seconds(from: date) > 0 { return "\(seconds(from: date))" }
   60|      0|        return ""
   61|      0|    }
   62|       |    
   63|       |    /// Return yyy MMM dd HH:mm from current date
   64|       |    ///
   65|       |    /// - Returns: date as descriptive string
   66|      0|    func getTimeWithYYYMMMDDHHmmFormat() -> String{
   67|      0|        return getTimeBy(format: "yyy MMM dd HH:mm")
   68|      0|    }
   69|       |
   70|       |    /// Return dd MMM yyy HH:mm from current date
   71|       |    ///
   72|       |    /// - Returns: date as descriptive string
   73|      0|    func getTimeWithDDMMMYYYHHmmFormat() -> String{
   74|      0|        return getTimeBy(format: "dd MMM yyy HH:mm")
   75|      0|    }
   76|       |    
   77|       |    /// Add some days to current date
   78|       |    ///
   79|       |    /// - Parameter days: days to add to your current date
   80|       |    /// - Returns: date as dd-MMM format with
   81|      0|    func getLeftDaysFrom(days:Int) -> String{
   82|      0|        let date = Calendar.current.date(byAdding: .day, value: days, to: self)!
   83|      0|        return date.getTimeBy(format: "dd-MMM")
   84|      0|    }
   85|       |    
   86|       |    /// Return date as string
   87|       |    ///
   88|       |    /// - Parameter format: formate descriptio
   89|       |    /// - Returns: date as descriptive string
   90|       |    func getTimeBy(format: String) -> String{
   91|       |        let dateFormatter = DateFormatter()
   92|       |        dateFormatter.dateFormat = format
   93|       |        return dateFormatter.string(from: self)
   94|       |    }
   95|       |    
   96|      0|    func isOlderAgainst(_ againstDate:Date) -> Bool{
   97|      0|        let dateLimit = NSCalendar.current.date(byAdding: .month, value: 3, to: self)
   98|      0|        if dateLimit! > againstDate{
   99|      0|            return true
  100|      0|        }
  101|      0|        return false
  102|      0|    }
  103|       |    
  104|      0|    func getTimeStamp() -> Int64{
  105|      0|        return Int64(self.timeIntervalSince1970)
  106|      0|    }
  107|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/Float+extension.swift:
    1|       |//
    2|       |//  Float+extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class Float_extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension Float {
   16|       |    
   17|      0|    func formatWithFractionDigits(_ fractionDigits: Int, customDecimalSeparator: String? = nil) -> String {
   18|      0|        
   19|      0|        let fmt = NumberFormatter()
   20|      0|        fmt.numberStyle = .decimal
   21|      0|        fmt.maximumFractionDigits = fractionDigits
   22|      0|        fmt.minimumFractionDigits = fractionDigits
   23|      0|        fmt.decimalSeparator = customDecimalSeparator ?? fmt.decimalSeparator
   24|      0|        
   25|      0|        return  fmt.string(from: NSNumber(value: self)) ?? ""
   26|      0|    }
   27|       |}
   28|       |
   29|       |extension CGFloat {
   30|      0|    static func random() -> CGFloat {
   31|      0|        return CGFloat(arc4random()) / CGFloat(UInt32.max)
   32|      0|    }
   33|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/Int+Extension.swift:
    1|       |//
    2|       |//  Int+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class Int_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension Int{
   16|      0|    func getTimeByOffset() -> Date{
   17|      0|        return Date(timeIntervalSince1970: TimeInterval(self))
   18|      0|    }
   19|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/SizesExtension.swift:
    1|       |//
    2|       |//  SizesExtension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Foundation
   11|       |
   12|       |enum iPhoneDevices {
   13|       |    case IPHONE_4
   14|       |    case IPHONE_5
   15|       |    case IPHONE_6
   16|       |    case IPHONE_6_PLUS
   17|       |    case IPHONE_X
   18|       |    case IPHONE_UNKNOWN
   19|       |}
   20|       |
   21|      0|var IPHONE_DEVICE: iPhoneDevices {
   22|      0|    let mainScreenBounds = UIScreen.main.bounds
   23|      0|    if mainScreenBounds.size.height == 480.0 || mainScreenBounds.size.width == 480.0 {
   24|      0|        return .IPHONE_4
   25|      0|    } else if mainScreenBounds.size.height == 568.0 || mainScreenBounds.size.width == 568.0 {
   26|      0|        return .IPHONE_5
   27|      0|    } else if mainScreenBounds.size.height == 667.0 || mainScreenBounds.size.width == 667.0 {
   28|      0|        return .IPHONE_6
   29|      0|    } else if mainScreenBounds.size.height == 736.0 || mainScreenBounds.size.width == 736.0 {
   30|      0|        return .IPHONE_6_PLUS
   31|      0|    } else if mainScreenBounds.size.height == 812.0 || mainScreenBounds.size.width == 812.0 {
   32|      0|        return .IPHONE_X
   33|      0|    }
   34|      0|    return .IPHONE_UNKNOWN
   35|      0|}
   36|       |
   37|       |//Created to support the sizes validations.
   38|       |@objc class SizesExtension: NSObject {
   39|       |    
   40|       |}
   41|       |

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/String+Extension.swift:
    1|       |//
    2|       |//  String+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class String_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |let __numberRegex = "^[0-9]\\d*(\\.\\d+)?$"
   16|       |let __firstpart = "[A-Z0-9a-z]([A-Z0-9a-z._%+-]{0,30}[A-Z0-9a-z])?"
   17|       |let __serverpart = "([A-Z0-9a-z]([A-Z0-9a-z-]{0,30}[A-Z0-9a-z])?\\.){1,5}"
   18|       |let __emailRegex = __firstpart + "@" + __serverpart + "[A-Za-z]{2,6}"
   19|       |let __emailPredicate = NSPredicate(format: "SELF MATCHES %@", __emailRegex)
   20|       |let __numberPredicate = NSPredicate(format: "SELF MATCHES %@", __numberRegex)
   21|       |
   22|       |public extension String {
   23|       |    
   24|      0|    func encodeUrl() -> String?{
   25|      0|        return self.addingPercentEncoding( withAllowedCharacters: NSCharacterSet.urlQueryAllowed)
   26|      0|    }
   27|      0|    func decodeUrl() -> String?{
   28|      0|        return self.removingPercentEncoding
   29|      0|    }
   30|       |    
   31|       |    func urlPercentEncoded(withAllowedCharacters allowedCharacters:
   32|      0|        CharacterSet, encoding: String.Encoding) -> String {
   33|      0|        var returnStr = ""
   34|      0|        
   35|      0|        // Compute each char seperatly
   36|      0|        for char in self {
   37|      0|            let charStr = String(char)
   38|      0|            let charScalar = charStr.unicodeScalars[charStr.unicodeScalars.startIndex]
   39|      0|            if allowedCharacters.contains(charScalar) == false,
   40|      0|                let bytesOfChar = charStr.data(using: encoding) {
   41|      0|                // Get the hexStr of every notAllowed-char-byte and put a % infront of it, append the result to the returnString
   42|      0|                for byte in bytesOfChar {
   43|      0|                    returnStr += "%" + String(format: "%02hhX", byte as CVarArg)
   44|      0|                }
   45|      0|            } else {
   46|      0|                returnStr += charStr
   47|      0|            }
   48|      0|        }
   49|      0|        
   50|      0|        return returnStr
   51|      0|    }
   52|       |    
   53|      0|    func isURL () -> Bool {
   54|      0|        if let url = NSURL(string: self) {
   55|      0|            // check if your application can open the NSURL instance
   56|      0|            return UIApplication.shared.canOpenURL(url as URL)
   57|      0|        }
   58|      0|        return false
   59|      0|    }
   60|       |    
   61|      3|    func isEmail() -> Bool {
   62|      3|        return __emailPredicate.evaluate(with: self)
   63|      3|    }
   64|       |    
   65|      4|    func isNumber() -> Bool{
   66|      4|        return __numberPredicate.evaluate(with: self)
   67|      4|    }
   68|       |    
   69|      1|    func toFloat(_ localeIdentifier: String? = nil) -> Float {
   70|      1|        let locale = localeIdentifier != nil ?  Locale(identifier: localeIdentifier!) : Locale.current
   71|      1|        
   72|      1|        let fmt = NumberFormatter()
   73|      1|        fmt.locale = locale
   74|      1|        fmt.numberStyle = .decimal
   75|      1|        fmt.maximumFractionDigits = 2
   76|      1|        fmt.roundingMode = .down
   77|      1|        
   78|      1|        return fmt.number(from: self)?.floatValue ?? 0
   79|      1|    }
   80|       |    
   81|      2|    var int : Int {
   82|      2|        if self.isNumber() {
   83|      1|            return Int(self.split(separator: ".")[0]) ?? 0
   84|      1|        } else {
   85|      1|            return 0
   86|      1|        }
   87|      0|    }
   88|       |    
   89|       |    
   90|      0|    func sliderAttributeString(intFont: UIFont, decimalFont: UIFont, customDecimalSeparator: String? = nil) -> NSAttributedString {
   91|      0|        guard self != "" else { return NSAttributedString(string: "") }
   92|      0|        
   93|      0|        let locale = Locale.current
   94|      0|        let fmt = NumberFormatter()
   95|      0|        fmt.locale = locale
   96|      0|        fmt.decimalSeparator = customDecimalSeparator ?? fmt.decimalSeparator
   97|      0|        
   98|      0|        let numberComponents = components(separatedBy: fmt.decimalSeparator)
   99|      0|        
  100|      0|        let attributeString = NSMutableAttributedString()
  101|      0|        var integerStr = numberComponents[0]
  102|      0|        
  103|      0|        var decimalStr = ""
  104|      0|        if numberComponents.count > 1 {
  105|      0|            integerStr += fmt.decimalSeparator
  106|      0|            decimalStr =  numberComponents[1]
  107|      0|        }
  108|      0|        
  109|      0|        let integer = NSMutableAttributedString(string: integerStr)
  110|      0|        let decimal = NSMutableAttributedString(string: decimalStr)
  111|      0|        
  112|      0|        
  113|      0|        attributeString.append(integer)
  114|      0|        attributeString.append(decimal)
  115|      0|        
  116|      0|        return attributeString
  117|      0|    }
  118|       |    
  119|       |    
  120|       |}
  121|       |
  122|       |public extension NSString{
  123|      0|    func getdBoldedText(boldPartsOfString: Array<NSString>, font: UIFont!, boldFont: UIFont!) -> NSAttributedString {
  124|      0|        
  125|      0|        let nonBoldFontAttribute = [NSAttributedString.Key.font:font!]
  126|      0|        let boldFontAttribute = [NSAttributedString.Key.font:boldFont!]
  127|      0|        let boldString = NSMutableAttributedString(string: self as String, attributes:nonBoldFontAttribute)
  128|      0|        for i in 0 ..< boldPartsOfString.count {
  129|      0|            boldString.addAttributes(boldFontAttribute, range: self.range(of: boldPartsOfString[i] as String))
  130|      0|        }
  131|      0|        return boldString
  132|      0|    }
  133|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/UIFont+Extension.swift:
    1|       |//
    2|       |//  UIFont+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class UIFont_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension UIFont {
   16|       |    
   17|       |    enum fontType{
   18|       |        case MAIN_ACTIONS
   19|       |    }
   20|       |    
   21|       |    static let fontForActionsOnMain = UIFont(fontType: .MAIN_ACTIONS)
   22|       |    
   23|      0|    convenience init(fontType: fontType) {
   24|      0|        if IPHONE_DEVICE == .IPHONE_5 {
   25|      0|            self.init(name: "Lato-Bold", size: 10)!
   26|      0|            return
   27|      0|        }
   28|      0|        self.init(name: "Lato-Bold", size: 14)!
   29|      0|    }
   30|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/UIWindow+Extension.swift:
    1|       |//
    2|       |//  UIWindow+Extension.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class UIWindow_Extension: NSObject {
   12|       |
   13|       |}
   14|       |
   15|       |extension UIWindow {
   16|      0|    func visibleViewController() -> UIViewController? {
   17|      0|        if let rootViewController: UIViewController = UIApplication.shared.keyWindow?.rootViewController {
   18|      0|            return UIWindow.getVisibleViewController(viewController: rootViewController)
   19|      0|        }
   20|      0|        return nil
   21|      0|    }
   22|       |    
   23|       |    class func getVisibleViewController(viewController: UIViewController?) -> UIViewController? {
   24|       |        if let navigationController = viewController as? UINavigationController {
   25|       |            return getVisibleViewController(viewController: navigationController.visibleViewController)
   26|       |        }
   27|       |        if let tabBarController = viewController as? UITabBarController {
   28|       |            return getVisibleViewController(viewController: tabBarController.selectedViewController)
   29|       |        }
   30|       |        if let splitViewController = viewController as? UISplitViewController {
   31|       |            return getVisibleViewController(viewController: splitViewController.viewControllers.last)
   32|       |        }
   33|       |        if let presentedViewController = viewController?.presentedViewController {
   34|       |            return getVisibleViewController(viewController: presentedViewController)
   35|       |        }
   36|       |        
   37|       |        return viewController
   38|       |    }
   39|       |    
   40|       |    
   41|      0|    func visibleViewControllerForWindow(window: UIWindow?,  exceptions: Array<AnyObject.Type>?) -> UIViewController? {
   42|      0|        if let rootViewController: UIViewController = window?.rootViewController {
   43|      0|            return UIWindow.getVisibleViewController(viewController: rootViewController, exceptions: exceptions)
   44|      0|        }
   45|      0|        return nil
   46|      0|    }
   47|       |    
   48|       |    class func getVisibleViewController(viewController: UIViewController?, exceptions: Array<AnyObject.Type>?) -> UIViewController? {
   49|       |        if let navigationController = viewController as? UINavigationController {
   50|       |            return getVisibleViewController(viewController: navigationController.visibleViewController, exceptions:exceptions)
   51|       |        }
   52|       |        if let tabBarController = viewController as? UITabBarController {
   53|       |            return getVisibleViewController(viewController: tabBarController.selectedViewController, exceptions:exceptions)
   54|       |        }
   55|       |        if let splitViewController = viewController as? UISplitViewController {
   56|       |            return getVisibleViewController(viewController: splitViewController.viewControllers.last, exceptions:exceptions)
   57|       |        }
   58|       |        if let presentedViewController = viewController?.presentedViewController {
   59|      0|            let numberCount = exceptions?.count ?? 0
   60|       |            if numberCount > 0 {
   61|       |                var allowed = true
   62|       |                for vcType in exceptions! {
   63|       |                    //                    print("Pvc Exception \(vcType), presentedview \(String(describing: presentedViewController)")
   64|       |                    if presentedViewController.isKind(of: vcType) {
   65|       |                        //                        print("Pvc Mismo tipo de pvc. Es un controlador no permitido, no se mostrará")
   66|       |                        allowed = false
   67|       |                        break
   68|       |                    }
   69|       |                }
   70|       |                if allowed {
   71|       |                    return getVisibleViewController(viewController: presentedViewController, exceptions:exceptions)
   72|       |                } else {
   73|       |                    return nil
   74|       |                }
   75|       |            } else {
   76|       |                return getVisibleViewController(viewController: presentedViewController, exceptions:exceptions)
   77|       |            }
   78|       |        }
   79|       |        
   80|       |        if let vc = viewController {
   81|      0|            let numberCount = exceptions?.count ?? 0
   82|       |            if numberCount > 0 {
   83|       |                var allowed = true
   84|       |                for vcType in exceptions! {
   85|       |                    //                    print("Exception \(vcType), presentedview \(String(describing: presentedViewController)")
   86|       |                    if vc.isKind(of: vcType) {
   87|       |                        //                        print("Mismo tipo de vc. Es un controlador no permitido, no se mostrará")
   88|       |                        allowed = false
   89|       |                        break
   90|       |                    }
   91|       |                }
   92|       |                if allowed {
   93|       |                    return viewController
   94|       |                } else {
   95|       |                    return nil
   96|       |                }
   97|       |            } else {
   98|       |                return viewController
   99|       |            }
  100|       |        } else {
  101|       |            return nil
  102|       |        }
  103|       |    }
  104|       |}
  105|       |

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/Extensions/ViewController+Extension.swift:
    1|       |//
    2|       |//  ViewController+ExtensionViewController.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 3/13/19.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ViewController_Extension: UIViewController {
   12|       |
   13|      0|    override func viewWillDisappear(_ animated: Bool) {
   14|      0|        view.endEditing(true)
   15|      0|    }
   16|       |    
   17|      0|    override func viewWillAppear(_ animated: Bool) {
   18|      0|        view.endEditing(true)
   19|      0|    }
   20|       |
   21|       |}
   22|       |
   23|       |// Put this piece of code anywhere you like
   24|       |extension UIViewController {
   25|      0|    func hideKeyboardWhenTappedAround() {
   26|      0|        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard))
   27|      0|        tap.cancelsTouchesInView = false
   28|      0|        view.addGestureRecognizer(tap)
   29|      0|    }
   30|       |    
   31|      0|    func hideKeyboardWhenTappedIn(currentView: UIView){
   32|      0|        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard))
   33|      0|        tap.cancelsTouchesInView = false
   34|      0|        currentView.addGestureRecognizer(tap)
   35|      0|    }
   36|       |    
   37|      0|    @objc func dismissKeyboard() {
   38|      0|        view.endEditing(true)
   39|      0|    }
   40|       |    
   41|       |    
   42|      0|    func  heightKeyboard() -> CGFloat{
   43|      0|        if UIDevice().userInterfaceIdiom == .phone {
   44|      0|            switch IPHONE_DEVICE{
   45|      0|            case .IPHONE_4:
   46|      0|                return 245.0
   47|      0|            case .IPHONE_5:
   48|      0|                return 250.0
   49|      0|            case .IPHONE_6:
   50|      0|                return 256.0
   51|      0|            case .IPHONE_6_PLUS:
   52|      0|                return 267.0
   53|      0|            case .IPHONE_X:
   54|      0|                return 298.0
   55|      0|            case .IPHONE_UNKNOWN:
   56|      0|                break
   57|      0|            }
   58|      0|        }
   59|      0|        return 256.0
   60|      0|    }
   61|       |    
   62|       |    
   63|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/UI&UX/AlertPickerSelector/AlertPickerSelectorViewController.swift:
    1|       |//
    2|       |//  AlertPickerSelectorViewController.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 10/27/17.
    6|       |//  Copyright © 2019 Gastando Tenis. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |protocol AlertPickerDelegate{
   12|       |    func dateSelected(_ dateSelected: Date, andTag: Int)
   13|       |}
   14|       |
   15|       |class AlertPickerSelectorViewController: UIViewController {
   16|       |
   17|       |    @IBOutlet weak var datePicker: UIDatePicker!
   18|       |    @IBOutlet weak var acceptBtn: UIButton!
   19|       |    @IBOutlet weak var cancelBtn: UIButton!
   20|       |    var delegate: AlertPickerDelegate?
   21|       |    var dateSelected = NSData()
   22|       |    var minDate = Date()
   23|       |    var tag = 0
   24|       |    
   25|      0|    override func viewDidLoad() {
   26|      0|        super.viewDidLoad()
   27|      0|        datePicker.minimumDate = minDate
   28|      0|        // Do any additional setup after loading the view.
   29|      0|    }
   30|       |
   31|      0|    override func didReceiveMemoryWarning() {
   32|      0|        super.didReceiveMemoryWarning()
   33|      0|        // Dispose of any resources that can be recreated.
   34|      0|    }
   35|       |    
   36|      0|    @IBAction func acceptAction(_ sender: Any) {
   37|      0|        delegate?.dateSelected(datePicker.date, andTag: tag)
   38|      0|        self.dismiss(animated: true, completion: nil)
   39|      0|    }
   40|       |    
   41|      0|    @IBAction func cancelAction(_ sender: Any) {
   42|      0|        self.dismiss(animated: true, completion: nil)
   43|      0|    }
   44|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/UI&UX/MessageObject.swift:
    1|       |//
    2|       |//  MesssageObject.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 19/01/18.
    6|       |//  Copyright © 2018 Luis Fernando Bustos Ramírez. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |final class MessageObject: NSObject {
   12|       |    
   13|       |    static let sharedInstance = MessageObject()
   14|       |    
   15|      0|    private override init() {super.init()}
   16|       |    
   17|      0|    func showMessage(_ message:String, title:String, okMessage:String){
   18|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: UIAlertController.Style.alert)
   19|      0|        let okAction = UIAlertAction(title: okMessage, style: UIAlertAction.Style.default) {
   20|      0|            (result : UIAlertAction) -> Void in
   21|      0|            print("OK")
   22|      0|        }
   23|      0|        if okMessage.count > 0{
   24|      0|            alertController.addAction(okAction)
   25|      0|        }
   26|      0|        
   27|      0|        let window = UIWindow.init(frame: UIScreen.main.bounds)
   28|      0|        window.rootViewController = UIViewController.init()
   29|      0|        window.windowLevel = UIWindow.Level.alert+1
   30|      0|        window.makeKeyAndVisible()
   31|      0|        window.rootViewController?.present(alertController, animated: true, completion: nil)
   32|      0|    }
   33|       |    
   34|      0|    func showMessage(_ message:String, title:String, okAction:UIAlertAction){
   35|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: UIAlertController.Style.alert)
   36|      0|        alertController.addAction(okAction)
   37|      0|        let window = UIWindow.init(frame: UIScreen.main.bounds)
   38|      0|        window.rootViewController = UIViewController.init()
   39|      0|        window.windowLevel = UIWindow.Level.alert+1
   40|      0|        window.makeKeyAndVisible()
   41|      0|        window.rootViewController?.present(alertController, animated: true, completion: nil)
   42|      0|    }
   43|       |    
   44|      0|    func showMessage(_ message:String, title:String, okAction:UIAlertAction, cancelAction:UIAlertAction){
   45|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: UIAlertController.Style.alert)
   46|      0|        alertController.addAction(okAction)
   47|      0|        alertController.addAction(cancelAction)
   48|      0|        let window = UIWindow.init(frame: UIScreen.main.bounds)
   49|      0|        window.rootViewController = UIViewController.init()
   50|      0|        window.windowLevel = UIWindow.Level.alert+1
   51|      0|        window.makeKeyAndVisible()
   52|      0|        window.rootViewController?.present(alertController, animated: true, completion: nil)
   53|      0|    }
   54|       |    
   55|      0|    func showMessage(_ message:String, title:String, okAction:UIAlertAction, cancelMessage:String){
   56|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: UIAlertController.Style.alert)
   57|      0|        alertController.addAction(okAction)
   58|      0|        let cancelAction = UIAlertAction(title: cancelMessage, style: UIAlertAction.Style.default) {
   59|      0|            (result : UIAlertAction) -> Void in
   60|      0|            print("OK")
   61|      0|        }
   62|      0|        alertController.addAction(cancelAction)
   63|      0|        let window = UIWindow.init(frame: UIScreen.main.bounds)
   64|      0|        window.rootViewController = UIViewController.init()
   65|      0|        window.windowLevel = UIWindow.Level.alert+1
   66|      0|        window.makeKeyAndVisible()
   67|      0|        window.rootViewController?.present(alertController, animated: true, completion: nil)
   68|      0|    }
   69|       |    
   70|      0|    func showMessageWithTextView(_ message:String, title:String, okMessage:String, cancelMessage:String, textPlaceHolder:String, completion:@escaping(String) ->Void){
   71|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: UIAlertController.Style.alert)
   72|      0|        alertController.addTextField { (textField: UITextField) in
   73|      0|            textField.keyboardAppearance = .dark
   74|      0|            textField.keyboardType = .default
   75|      0|            textField.autocorrectionType = .default
   76|      0|            textField.placeholder = textPlaceHolder
   77|      0|            textField.clearButtonMode = .whileEditing
   78|      0|        }
   79|      0|        let cancelAction = UIAlertAction(title: cancelMessage, style: UIAlertAction.Style.default) {
   80|      0|            (result : UIAlertAction) -> Void in
   81|      0|            completion("")
   82|      0|        }
   83|      0|        let submitAction = UIAlertAction(title: okMessage, style: .default, handler: { (action) -> Void in
   84|      0|            let textField = alertController.textFields![0]
   85|      0|            completion(textField.text!)
   86|      0|        })
   87|      0|        alertController.addAction(submitAction)
   88|      0|        alertController.addAction(cancelAction)
   89|      0|        let window = UIWindow.init(frame: UIScreen.main.bounds)
   90|      0|        window.rootViewController = UIViewController.init()
   91|      0|        window.windowLevel = UIWindow.Level.alert+1
   92|      0|        window.makeKeyAndVisible()
   93|      0|        window.rootViewController?.present(alertController, animated: true, completion: nil)
   94|      0|    
   95|      0|    }
   96|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/UI&UX/Reachability/Reachability.swift:
    1|       |/*
    2|       | Copyright (c) 2014, Ashley Mills
    3|       | All rights reserved.
    4|       | 
    5|       | Redistribution and use in source and binary forms, with or without
    6|       | modification, are permitted provided that the following conditions are met:
    7|       | 
    8|       | 1. Redistributions of source code must retain the above copyright notice, this
    9|       | list of conditions and the following disclaimer.
   10|       | 
   11|       | 2. Redistributions in binary form must reproduce the above copyright notice,
   12|       | this list of conditions and the following disclaimer in the documentation
   13|       | and/or other materials provided with the distribution.
   14|       | 
   15|       | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   16|       | AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   17|       | IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   18|       | ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   19|       | LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   20|       | CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   21|       | SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   22|       | INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   23|       | CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   24|       | ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   25|       | POSSIBILITY OF SUCH DAMAGE.
   26|       | */
   27|       |
   28|       |import SystemConfiguration
   29|       |import Foundation
   30|       |
   31|       |public enum ReachabilityError: Error {
   32|       |    case FailedToCreateWithAddress(sockaddr_in)
   33|       |    case FailedToCreateWithHostname(String)
   34|       |    case UnableToSetCallback
   35|       |    case UnableToSetDispatchQueue
   36|       |    case UnableToSetMainLoop
   37|       |}
   38|       |
   39|       |@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
   40|       |public let ReachabilityChangedNotification = NSNotification.Name("ReachabilityChangedNotification")
   41|       |
   42|       |extension Notification.Name {
   43|       |    public static let reachabilityChanged = Notification.Name("reachabilityChanged")
   44|       |}
   45|       |
   46|      0|func callback(reachability: SCNetworkReachability, flags: SCNetworkReachabilityFlags, info: UnsafeMutableRawPointer?) {
   47|      0|    guard let info = info else { return }
   48|      0|    
   49|      0|    let reachability = Unmanaged<Reachability>.fromOpaque(info).takeUnretainedValue()
   50|      0|    reachability.reachabilityChanged()
   51|      0|}
   52|       |
   53|       |public class Reachability {
   54|       |    
   55|       |    public typealias NetworkReachable = (Reachability) -> ()
   56|       |    public typealias NetworkUnreachable = (Reachability) -> ()
   57|       |    
   58|       |    @available(*, unavailable, renamed: "Connection")
   59|       |    public enum NetworkStatus: CustomStringConvertible {
   60|       |        case notReachable, reachableViaWiFi, reachableViaWWAN
   61|      0|        public var description: String {
   62|      0|            switch self {
   63|      0|            case .reachableViaWWAN: return "Cellular"
   64|      0|            case .reachableViaWiFi: return "WiFi"
   65|      0|            case .notReachable: return "No Connection"
   66|      0|            }
   67|      0|        }
   68|       |    }
   69|       |    
   70|       |    public enum Connection: CustomStringConvertible {
   71|       |        case none, wifi, cellular
   72|      0|        public var description: String {
   73|      0|            switch self {
   74|      0|            case .cellular: return "Cellular"
   75|      0|            case .wifi: return "WiFi"
   76|      0|            case .none: return "No Connection"
   77|      0|            }
   78|      0|        }
   79|       |    }
   80|       |    
   81|       |    public var whenReachable: NetworkReachable?
   82|       |    public var whenUnreachable: NetworkUnreachable?
   83|       |    
   84|       |    @available(*, deprecated: 4.0, renamed: "allowsCellularConnection")
   85|       |    public let reachableOnWWAN: Bool = true
   86|       |    
   87|       |    /// Set to `false` to force Reachability.connection to .none when on cellular connection (default value `true`)
   88|       |    public var allowsCellularConnection: Bool
   89|       |    
   90|       |    // The notification center on which "reachability changed" events are being posted
   91|       |    public var notificationCenter: NotificationCenter = NotificationCenter.default
   92|       |    
   93|       |    @available(*, deprecated: 4.0, renamed: "connection.description")
   94|      0|    public var currentReachabilityString: String {
   95|      0|        return "\(connection)"
   96|      0|    }
   97|       |    
   98|       |    @available(*, unavailable, renamed: "connection")
   99|      0|    public var currentReachabilityStatus: Connection {
  100|      0|        return connection
  101|      0|    }
  102|       |    
  103|      0|    public var connection: Connection {
  104|      0|        guard isReachableFlagSet else { return .none }
  105|      0|        
  106|      0|        // If we're reachable, but not on an iOS device (i.e. simulator), we must be on WiFi
  107|      0|        guard isRunningOnDevice else { return .wifi }
  108|      0|        
  109|      0|        var connection = Connection.none
  110|      0|        
  111|      0|        if !isConnectionRequiredFlagSet {
  112|      0|            connection = .wifi
  113|      0|        }
  114|      0|        
  115|      0|        if isConnectionOnTrafficOrDemandFlagSet {
  116|      0|            if !isInterventionRequiredFlagSet {
  117|      0|                connection = .wifi
  118|      0|            }
  119|      0|        }
  120|      0|        
  121|      0|        if isOnWWANFlagSet {
  122|      0|            if !allowsCellularConnection {
  123|      0|                connection = .none
  124|      0|            } else {
  125|      0|                connection = .cellular
  126|      0|            }
  127|      0|        }
  128|      0|        
  129|      0|        return connection
  130|      0|    }
  131|       |    
  132|       |    fileprivate var previousFlags: SCNetworkReachabilityFlags?
  133|       |    
  134|      0|    fileprivate var isRunningOnDevice: Bool = {
  135|      0|        #if targetEnvironment(simulator)
  136|      0|        return false
  137|      0|        #else
  138|      0|        return true
  139|      0|        #endif
  140|      0|    }()
  141|       |    
  142|       |    fileprivate var notifierRunning = false
  143|       |    fileprivate let reachabilityRef: SCNetworkReachability
  144|       |    
  145|       |    
  146|       |    fileprivate var usingHostname = false
  147|       |    
  148|      0|    required public init(reachabilityRef: SCNetworkReachability, usingHostname: Bool = false) {
  149|      0|        allowsCellularConnection = true
  150|      0|        self.reachabilityRef = reachabilityRef
  151|      0|        self.usingHostname = usingHostname
  152|      0|    }
  153|       |    
  154|      0|    public convenience init?(hostname: String) {
  155|      0|        guard let ref = SCNetworkReachabilityCreateWithName(nil, hostname) else { return nil }
  156|      0|        self.init(reachabilityRef: ref, usingHostname: true)
  157|      0|    }
  158|       |    
  159|      0|    public convenience init?() {
  160|      0|        var zeroAddress = sockaddr()
  161|      0|        zeroAddress.sa_len = UInt8(MemoryLayout<sockaddr>.size)
  162|      0|        zeroAddress.sa_family = sa_family_t(AF_INET)
  163|      0|        
  164|      0|        guard let ref = SCNetworkReachabilityCreateWithAddress(nil, &zeroAddress) else { return nil }
  165|      0|        
  166|      0|        self.init(reachabilityRef: ref)
  167|      0|    }
  168|       |    
  169|      0|    deinit {
  170|      0|        stopNotifier()
  171|      0|    }
  172|       |}
  173|       |
  174|       |public extension Reachability {
  175|       |    
  176|       |    // MARK: - *** Notifier methods ***
  177|      0|    func startNotifier() throws {
  178|      0|        guard !notifierRunning else { return }
  179|      0|        
  180|      0|        var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil)
  181|      0|        context.info = UnsafeMutableRawPointer(Unmanaged<Reachability>.passUnretained(self).toOpaque())
  182|      0|        if !SCNetworkReachabilitySetCallback(reachabilityRef, callback, &context) {
  183|      0|            stopNotifier()
  184|      0|            throw ReachabilityError.UnableToSetCallback
  185|      0|        }
  186|      0|        
  187|      0|        if (SCNetworkReachabilityScheduleWithRunLoop(reachabilityRef, CFRunLoopGetCurrent(), RunLoop.Mode.default as CFString)) {
  188|      0|            self.reachabilityChanged()
  189|      0|            notifierRunning = true
  190|      0|        } else {
  191|      0|            stopNotifier()
  192|      0|            notifierRunning = false
  193|      0|            throw ReachabilityError.UnableToSetMainLoop
  194|      0|        }
  195|      0|    }
  196|       |    
  197|       |    func stopNotifier() {
  198|       |        defer { notifierRunning = false }
  199|       |        
  200|       |        SCNetworkReachabilitySetCallback(reachabilityRef, nil, nil)
  201|       |        SCNetworkReachabilitySetDispatchQueue(reachabilityRef, nil)
  202|       |    }
  203|       |    
  204|       |    // MARK: - *** Connection test methods ***
  205|       |    @available(*, deprecated: 4.0, message: "Please use `connection != .none`")
  206|      0|    var isReachable: Bool {
  207|      0|        guard isReachableFlagSet else { return false }
  208|      0|        
  209|      0|        if isConnectionRequiredAndTransientFlagSet {
  210|      0|            return false
  211|      0|        }
  212|      0|        
  213|      0|        if isRunningOnDevice {
  214|      0|            if isOnWWANFlagSet && !reachableOnWWAN {
  215|      0|                // We don't want to connect when on cellular connection
  216|      0|                return false
  217|      0|            }
  218|      0|        }
  219|      0|        
  220|      0|        return true
  221|      0|    }
  222|       |    
  223|       |    @available(*, deprecated: 4.0, message: "Please use `connection == .cellular`")
  224|      0|    var isReachableViaWWAN: Bool {
  225|      0|        // Check we're not on the simulator, we're REACHABLE and check we're on WWAN
  226|      0|        return isRunningOnDevice && isReachableFlagSet && isOnWWANFlagSet
  227|      0|    }
  228|       |    
  229|       |    @available(*, deprecated: 4.0, message: "Please use `connection == .wifi`")
  230|      0|    var isReachableViaWiFi: Bool {
  231|      0|        // Check we're reachable
  232|      0|        guard isReachableFlagSet else { return false }
  233|      0|        
  234|      0|        // If reachable we're reachable, but not on an iOS device (i.e. simulator), we must be on WiFi
  235|      0|        guard isRunningOnDevice else { return true }
  236|      0|        
  237|      0|        // Check we're NOT on WWAN
  238|      0|        return !isOnWWANFlagSet
  239|      0|    }
  240|       |    
  241|      0|    var description: String {
  242|      0|        let W = isRunningOnDevice ? (isOnWWANFlagSet ? "W" : "-") : "X"
  243|      0|        let R = isReachableFlagSet ? "R" : "-"
  244|      0|        let c = isConnectionRequiredFlagSet ? "c" : "-"
  245|      0|        let t = isTransientConnectionFlagSet ? "t" : "-"
  246|      0|        let i = isInterventionRequiredFlagSet ? "i" : "-"
  247|      0|        let C = isConnectionOnTrafficFlagSet ? "C" : "-"
  248|      0|        let D = isConnectionOnDemandFlagSet ? "D" : "-"
  249|      0|        let l = isLocalAddressFlagSet ? "l" : "-"
  250|      0|        let d = isDirectFlagSet ? "d" : "-"
  251|      0|        
  252|      0|        return "\(W)\(R) \(c)\(t)\(i)\(C)\(D)\(l)\(d)"
  253|      0|    }
  254|       |}
  255|       |
  256|       |fileprivate extension Reachability {
  257|       |    func reachabilityChanged() {
  258|       |        guard previousFlags != flags else { return }
  259|       |        
  260|       |        let block = connection != .none ? whenReachable : whenUnreachable
  261|       |        
  262|      0|        DispatchQueue.main.async {
  263|      0|            if self.usingHostname {
  264|      0|                //print("USING HOSTNAME ABOUT TO CALL BLOCK")
  265|      0|            }
  266|      0|            block?(self)
  267|      0|            self.notificationCenter.post(name: .reachabilityChanged, object:self)
  268|      0|        }
  269|       |        
  270|       |        previousFlags = flags
  271|       |    }
  272|       |    
  273|       |    var isOnWWANFlagSet: Bool {
  274|       |        #if os(iOS)
  275|       |        return flags.contains(.isWWAN)
  276|       |        #else
  277|       |        return false
  278|       |        #endif
  279|       |    }
  280|       |    var isReachableFlagSet: Bool {
  281|       |        return flags.contains(.reachable)
  282|       |    }
  283|       |    var isConnectionRequiredFlagSet: Bool {
  284|       |        return flags.contains(.connectionRequired)
  285|       |    }
  286|       |    var isInterventionRequiredFlagSet: Bool {
  287|       |        return flags.contains(.interventionRequired)
  288|       |    }
  289|       |    var isConnectionOnTrafficFlagSet: Bool {
  290|       |        return flags.contains(.connectionOnTraffic)
  291|       |    }
  292|       |    var isConnectionOnDemandFlagSet: Bool {
  293|       |        return flags.contains(.connectionOnDemand)
  294|       |    }
  295|       |    var isConnectionOnTrafficOrDemandFlagSet: Bool {
  296|       |        return !flags.intersection([.connectionOnTraffic, .connectionOnDemand]).isEmpty
  297|       |    }
  298|       |    var isTransientConnectionFlagSet: Bool {
  299|       |        return flags.contains(.transientConnection)
  300|       |    }
  301|       |    var isLocalAddressFlagSet: Bool {
  302|       |        return flags.contains(.isLocalAddress)
  303|       |    }
  304|       |    var isDirectFlagSet: Bool {
  305|       |        return flags.contains(.isDirect)
  306|       |    }
  307|       |    var isConnectionRequiredAndTransientFlagSet: Bool {
  308|       |        return flags.intersection([.connectionRequired, .transientConnection]) == [.connectionRequired, .transientConnection]
  309|       |    }
  310|       |    
  311|       |    var flags: SCNetworkReachabilityFlags {
  312|       |        var flags = SCNetworkReachabilityFlags()
  313|       |        if SCNetworkReachabilityGetFlags(reachabilityRef, &flags) {
  314|       |            //print("Returning flags \(flags)")
  315|       |            return flags
  316|       |        } else {
  317|       |            return SCNetworkReachabilityFlags()
  318|       |        }
  319|       |    }
  320|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/UI&UX/Reachability/ReachabilityManager.swift:
    1|       |//
    2|       |//  ReachabilityManager.swift
    3|       |//  ReachabilityTest
    4|       |//
    5|       |//  Created by Janet García on 8/27/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |//Known before as InternetServices
   11|       |class ReachabilityManager: NSObject {
   12|       |    
   13|       |    static let sharedInstance = ReachabilityManager()
   14|       |    var reachability: Reachability?
   15|       |    var internetStatus: Reachability.Connection = .none
   16|       |    var isInternetAvaliable = false
   17|       |    
   18|      0|    private override init() {
   19|      0|        super.init()
   20|      0|        
   21|      0|        reachability = Reachability()
   22|      0|        startNotifier()
   23|      0|        isInternetAvailable()
   24|      0|        NotificationCenter.default.addObserver(self, selector: #selector(showInetStatus(_:)), name: .reachabilityChanged, object: reachability
   25|      0|        )
   26|      0|    }
   27|       |    
   28|      0|    func startNotifier() {
   29|      0|        print("JG Internet --- start notifier")
   30|      0|        do {
   31|      0|            try reachability?.startNotifier()
   32|      0|        } catch {
   33|      0|            print("JG Internet Unable to start\nnotifier")
   34|      0|            return
   35|      0|        }
   36|      0|    }
   37|       |    
   38|       |    //showInetStatus & reachabilityChangedSelector methods replacement
   39|      0|    @objc func showInetStatus(_ note: Notification) {
   40|      0|        reachabilityChangedSelector()
   41|      0|    }
   42|       |    
   43|      0|    func reachabilityChangedSelector() {
   44|      0|        let internetConnectionStatus: Reachability.Connection = reachability?.connection ?? .none
   45|      0|        var dictionary = [String:String]()
   46|      0|        switch internetConnectionStatus {
   47|      0|        case .cellular:
   48|      0|            dictionary["Status"] = "1"
   49|      0|            dictionary["medium"] = "ReachableViaWWAN"
   50|      0|            internetStatus = .cellular
   51|      0|            isInternetAvaliable = true
   52|      0|            print("Internet ReachableViaWWAN available")
   53|      0|            break
   54|      0|        case .wifi:
   55|      0|            dictionary["Status"] = "1"
   56|      0|            dictionary["medium"] = "ReachableViaWiFi"
   57|      0|            internetStatus = .wifi
   58|      0|            isInternetAvaliable = true
   59|      0|            print("Internet ReachableViaWiFi available")
   60|      0|            
   61|      0|            break
   62|      0|        case .none:
   63|      0|            dictionary["Status"] = "0"
   64|      0|            dictionary["medium"] = "global_lbl_rednodisponible_1"
   65|      0|            internetStatus = .none
   66|      0|            isInternetAvaliable = false
   67|      0|            print("Internet NOT available")
   68|      0|            
   69|      0|            break
   70|      0|        }
   71|      0|        
   72|      0|        internetConnectionBanner()
   73|      0|    }
   74|       |    
   75|      0|    func internetConnectionBanner() {
   76|      0|        if ReachabilityManager.sharedInstance.isInternetAvaliable {
   77|      0|            //BannerViewManager.shared.hideBannerView(ofType: .INTERNET)
   78|      0|        } else {
   79|      0|            //BannerViewManager.shared.showBannerView(ofType: .INTERNET)
   80|      0|        }
   81|      0|    }
   82|       |    
   83|      0|    func isInternetAvailable() {
   84|      0|        if let internetStatus: Reachability.Connection = reachability?.connection {
   85|      0|            if internetStatus != .none {
   86|      0|                isInternetAvaliable = true
   87|      0|            } else {
   88|      0|                isInternetAvaliable = false
   89|      0|            }
   90|      0|        } else {
   91|      0|            isInternetAvaliable = false
   92|      0|        }
   93|      0|    }
   94|       |}

/Users/luisfernandobustosramirez/Documents/GitHub/LFBR.SwiftLib/LFBR.SwiftLib/UI&UX/TriangleView.swift:
    1|       |//
    2|       |//  TriangleView.swift
    3|       |//  ExtensionManager
    4|       |//
    5|       |//  Created by Luis Fernando Bustos Ramírez on 2/2/18.
    6|       |//  Copyright © 2018 Luis Fernando Bustos Ramírez. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class TriangleSended : UIView {
   12|       |    
   13|      0|    override init(frame: CGRect) {
   14|      0|        super.init(frame: frame)
   15|      0|    }
   16|       |    
   17|      0|    required init?(coder aDecoder: NSCoder) {
   18|      0|        super.init(coder: aDecoder)
   19|      0|    }
   20|       |    
   21|      0|    override func draw(_ rect: CGRect) {
   22|      0|        
   23|      0|        guard let context = UIGraphicsGetCurrentContext() else { return }
   24|      0|        
   25|      0|        context.beginPath()
   26|      0|        context.move(to: CGPoint(x: rect.minX, y: rect.minY))
   27|      0|        context.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
   28|      0|        context.addLine(to: CGPoint(x: (rect.maxX), y: rect.minY))
   29|      0|        context.closePath()
   30|      0|        
   31|      0|        context.setFillColor(UIColor.lightGray.cgColor)
   32|      0|        context.fillPath()
   33|      0|    }
   34|       |}
   35|       |
   36|       |class TriangleRecived : UIView {
   37|       |    
   38|      0|    override init(frame: CGRect) {
   39|      0|        super.init(frame: frame)
   40|      0|    }
   41|       |    
   42|      0|    required init?(coder aDecoder: NSCoder) {
   43|      0|        super.init(coder: aDecoder)
   44|      0|    }
   45|       |    
   46|      0|    override func draw(_ rect: CGRect) {
   47|      0|        
   48|      0|        guard let context = UIGraphicsGetCurrentContext() else { return }
   49|      0|        
   50|      0|        context.beginPath()
   51|      0|        context.move(to: CGPoint(x: rect.minX, y: rect.maxY))
   52|      0|        context.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
   53|      0|        context.addLine(to: CGPoint(x: (rect.minX / 2.0), y: rect.minY))
   54|      0|        context.closePath()
   55|      0|        
   56|      0|        context.setFillColor(UIColor.lightGray.cgColor)
   57|      0|        context.fillPath()
   58|      0|    }
   59|       |}

